[[oop]]
== 객체 지향 프로그래밍

지금까지 프로그램을 작성할 때, 우리는 데이터를 다루는 명령들의 블록인 함수들의 조합으로 프로그램을
구성하였습니다. 이러한 설계 방식을 _절차 지향_ 프로그래밍 기법이라고 부릅니다. 이와 달리
데이터와 기능을 객체라고 불리우는 것으로 묶어서 프로그램을 구성하는 또 다른 기법이 있습니다.
이것을 _객체 지향_ 프로그래밍 기법이라고 부릅니다. 아마도 여러분의 대부분의 시간 동안 절차 지향
프로그래밍 기법을 통해 프로그램을 작성하게 되겠지만, 큰 프로그램을 작성할 때나 이 기법을
이용하는 것이 더 편리한 문제를 해결해야 할 경우 객체 지향 프로그래밍 기법을 활용할 수 있습니다.

객체 지향 프로그래밍에서는 클래스와 객체라는 두 가지 주인공이 있습니다. *클래스*는 새로운 _형식_
을 정의하는 것이며, *객체*는 클래스의 *인스턴스* 를 의미하는 것입니다. 이것을 다시 표현하면
여러분이 `int` 라는 형식의 변수를 만들 수 있다는 것으로, 이것은 곧 정수형을 저장하는 변수는
`int` 클래스의 인스턴스(객체)를 변수에 할당하는 것이라고도 말할 수 있습니다.

.정적 언어 프로그래머들을 위한 주석
[NOTE]
--
파이썬에서는 정수형조차도 객체로 다루어집니다 (`int` 클래스의 객체입니다). C++이나 Java
(버전 1.5 미만)처럼 정수형이 자체 기본 형식들 중 하나로 다루어지는 것과는 다릅니다.

`help(int)` 를 입력하여 정수형 클래스에 대해 좀 더 자세히 알아보시기 바랍니다.

C# 이나 Java 1.5 프로그래머들은 아마 이것이 _boxing 과 unboxing_ 과 비슷하다는 것을
눈치채셨을 것입니다.
--

객체는 그 객체에 _내장된_ 일반적인 변수들을 사용하여 데이터를 저장할 수 있습니다. 이 때 객체 혹은
클래스에 소속된 변수들을 *필드(field)* 라고 부릅니다. 객체는 또한 _내장된_ 함수를 이용하여 어떤
기능을 갖도록 할 수 있는데 이것을 클래스의 *메소드(method)* 라고 부릅니다. 이러한 명칭을
구별하여 부르는 것은 중요한데, 이는 일반적인 변수와 함수와 달리 이들은 클래스나 객체에 소속되어
있는 대상들이기 때문입니다. 또, 이러한 필드와 메소드들을 통틀어 클래스의 *속성(attribute)* 이라
부릅니다.

필드는 두 가지 종류가 있습니다. 하나는 클래스의 인스턴스/객체에 내장되어 있는 것이고, 또 하나는
클래스 자체에 내장되어 있는 것입니다. 각각을 *인스턴스 변수* 와 *클래스 변수* 라 부릅니다.

클래스는 `class` 키워드를 통해 생성됩니다. 클래스의 필드와 메소드는 그 아래 들여쓰기 된 블록에
차례로 정의됩니다.

[[self]]
=== +self+ 에 대하여

클래스 메소드는 일반적인 함수와 딱 한 가지 다른 점이 있는데, 그것은 메소드의 경우 매개 변수의
목록에 항상 추가로 한 개의 변수가 맨 앞에 추가되어야 한다는 점입니다. 또한 메소드를 호출할 때
이 변수에는 우리가 직접 값을 넘겨주지 *않으며*, 대신 파이썬이 자동으로 값을 할당합니다.
이 변수에는 현재 객체 _자신의_ 참조가 할당되며, 일반적으로 `self` 라 이름을 짓습니다.

이 변수의 이름은 마음대로 지을 수 있지만, `self` 라는 이름을 사용할 것을 _강력히 권합니다_.
이것은 어떤 약속으로, 다른 이름을 사용하는 것은 다른 프로그래머들에게 좀 눈살을 찌푸려지게 하는
일이 될 수 있기 때문입니다. `self`라는 표준적인 이름을 사용하면 여러분의 프로그램을 읽는
사람들로부터 이것이 그것을 의마함을 쉽게 알아보게 할 수 있고, 심지어 특별한 IDE (Integrated
Development Environment)를 사용하는 사람들도 이를 쉽게 알아볼 수 있는 등 여러 장점이 있습니다.

.C++/Java/C# 프로그래머를 위한 주석
[NOTE]
파이썬의 `self` 는 C++ 의 `this` 포인터와 같은 것이며, Java와 C# 의 `this` 참조와 같습니다.

아마 여러분은 파이썬이 `self` 에 어떻게 값을 할당하는 것인지 그리고 정말 값을 직접 할당할 필요가
없는지 궁금할 것입니다. 이해를 돕기 위해 예를 하나 들어 보겠습니다. 여러분이 `MyClass` 라는
클래스를 생성했고, 이 클래스의 객체를 `myobject` 라는 이름으로 생성했다고 해 봅시다. 이제 이
객체의 메소드를 호출할 때는 `myobject.method(arg1, arg2)` 와 같이 하며, 이것은 파이썬에 의해
자동적으로 `MyClass.method(myobject, arg1, arg2)` 의 형태로 바뀌게 됩니다. 이것이 `self`
에 대한 모든 것입니다.

또한 이것은 아무런 인수도 넘겨받지 않는 메소드를 정의할 때에도, `self` 라는 하나의 인수를
추가해 주어야 한다는 것을 의미합니다.

[[class]]
=== 클래스

가장 단순한 클래스의 예시가 아래 예제에 나타나 있습니다(`oop_simplestclass.py` 로 저장하세요).

[source,python]
--------------------------------------------------
include::programs/oop_simplestclass.py[]
--------------------------------------------------

출력 예시:

--------------------------------------------------
include::programs/oop_simplestclass.txt[]
--------------------------------------------------

.동작 원리

먼저 `class` 문을 사용하여 새로운 클래스를 생성하였고 적당한 이름을 지어 주었습니다. 그 아래로는
들여쓰기 된 새로운 블록이 시작되며 이 블록은 클래스의 몸체를 구성합니다. 위 예제의 경우에는
`pass` 문으로 해당 블록이 빈 블록임을 나타내 주었습니다.

다음으로, 이 클래스의 이름 뒤에 괄호를 열고 닫아 주어 클래스의 객체/인스턴스를 만들었습니다
(다음 섹션에서 <<init,객체 초기화>> 에 대해 좀 더 자세히 배울 것입니다). 객체가 잘 생성되었는지
확인해 보기 위해, 정의한 변수명을 입력하여 결과를 확인해 봅니다. 그러면 이 객체는 `__main__` 모듈의
`Person` 클래스의 인스턴스임을 알 수 있습니다.

또 객체가 실제로 저장된 컴퓨터 메모리의 위치가 함께 반환되는 것을 확인하시기 바랍니다. 컴퓨터마다
그 객체를 저장하기 위한 빈 공간이 위치한 곳이 다를 것이므로 컴퓨터마다 이 값은 다르게 출력될
것입니다.

[[methods]]
=== 메소드

앞서 클래스/객체는 메소드를 가질 수 있으며, 메소드는 추가된 `self` 변수를 제외하고 함수와 똑같다는
것에 대해 이야기했습니다. 아래는 예제입니다(`oop_method.py` 로 저장하세요).

[source,python]
--------------------------------------------------
include::programs/oop_method.py[]
--------------------------------------------------

출력 예시:

--------------------------------------------------
include::programs/oop_method.txt[]
--------------------------------------------------

.동작 원리

위 예제는 `self` 가 어떻게 동작하는지 보여줍니다. 여기서 `say_hi` 메소드는 아무 매개 변수도 
넘겨받지 않지만 함수 정의에 `self` 를 가지고 있음을 확인하시기 바랍니다.

[[init]]
=== `__init__` 메소드

파이썬의 클래스에는 여러가지 특별한 메소드 이름이 존재합니다. 우선 그 중 `__init__` 메소드의
중요성에 대해 알아보겠습니다.

`__init__` 메소드는 클래스가 인스턴스화 될 때 호출됩니다. 따라서 이 메소드는 객체가 생성될 때
여러가지 *초기화* 명령들이 필요할 때 유용하게 사용됩니다. 여기서 init의 앞과 뒤에 있는 밑줄은
두 번씩 입력해야 한다는 점을 기억하시기 바랍니다.

예제 (`oop_init.py` 로 저장하세요):

[source,python]
--------------------------------------------------
include::programs/oop_init.py[]
--------------------------------------------------

출력 예시:

--------------------------------------------------
include::programs/oop_init.txt[]
--------------------------------------------------

.동작 원리

먼저 매개 변수 `name` 을 넘겨 받는 `__init__` 메소드를 정의합니다(물론 `self`를 포함하여 정의합니다).
그리고, `name` 이라는 필드를 생성합니다. 이 때 두 다른 변수의 이름으로 'name' 이라는 동일한
이름을 지정해 주었다는 점에 주목하시기 바랍니다. 이것이 문제가 되지 않는 이유는 하나는
"self" 라 칭해지는 객체에 내장된 것으로써 `self.name` 의 형태로 사용되며 또 하나인 `name` 은
지역 변수를 의미하는 것으로 사용되기 때문입니다. 프로그램 상에서 각각을 완전하게 구분할
수 있으므로, 혼란이 일어나지 않습니다.

위 예제에서 가장 중요한 것은, 우리가 `__init__` 메소드를 직접 호출해 주지 않고 클래스로부터
인스턴스를 생성할 때 괄호 안에 인수를 함께 넘겨 주었다는 점입니다. 이 점이 이 메소드가 좀
특별하게 다뤄지는 이유입니다.

이제, `sayHi` 메소드에서처럼 객체 내부에서 `self.name` 필드를 사용할 수 있습니다.

[[class_obj_vars]]
=== 클래스 변수와 객체 변수

We have already discussed the functionality part of classes and objects (i.e. methods), now let us
learn about the data part. The data part, i.e. fields, are nothing but ordinary variables that are
_bound_ to the *namespaces* of the classes and objects. This means that these names are valid
within the context of these classes and objects only. That's why they are called _name spaces_.

There are two types of _fields_ - class variables and object variables which are classified
depending on whether the class or the object _owns_ the variables respectively.

*Class variables* are shared - they can be accessed by all instances of that class. There is only
one copy of the class variable and when any one object makes a change to a class variable, that
change will be seen by all the other instances.

*Object variables* are owned by each individual object/instance of the class. In this case, each
object has its own copy of the field i.e. they are not shared and are not related in any way to the
field by the same name in a different instance. An example will make this easy to understand (save
as `oop_objvar.py`):

[source,python]
--------------------------------------------------
include::programs/oop_objvar.py[]
--------------------------------------------------

Output:

--------------------------------------------------
include::programs/oop_objvar.txt[]
--------------------------------------------------

.How It Works

This is a long example but helps demonstrate the nature of class and object variables. Here,
`population` belongs to the`Robot` class and hence is a class variable. The `name` variable belongs
to the object (it is assigned using `self`) and hence is an object variable.

Thus, we refer to the `population` class variable as `Robot.population` and not as
`self.population`. We refer to the object variable `name` using `self.name` notation in the methods
of that object. Remember this simple difference between class and object variables. Also note that
an object variable with the same name as a class variable will hide the class variable!

Instead of `Robot.population`, we could have also used `self.__class__.population` because every
object refers to it's class via the `self.__class__` attribute.

The `how_many` is actually a method that belongs to the class and not to the object. This means we
can define it as either a `classmethod` or a `staticmethod` depending on whether we need to know
which class we are part of. Since we refer to a class variable, let's use `classmethod`.

We have marked the `how_many` method as a class method using a <<decorator,decorator>>.

Decorators can be imagined to be a shortcut to calling a wrapper function, so applying the
`@classmethod` decorator is same as calling:

[source,python]
--------------------------------------------------
how_many = classmethod(how_many)
--------------------------------------------------

Observe that the `__init__` method is used to initialize the `Robot` instance with a name. In this
method, we increase the `population` count by 1 since we have one more robot being added. Also
observe that the values of `self.name` is specific to each object which indicates the nature of
object variables.

Remember, that you must refer to the variables and methods of the same object using the `self`
*only*. This is called an *attribute reference*.

In this program, we also see the use of *docstrings* for classes as well as methods. We can access
the class docstring at runtime using `Robot.__doc__` and the method docstring as
`Robot.say_hi.__doc__`

In the `die` method, we simply decrease the `Robot.population` count by 1.

All class members are public. One exception: If you use data members with names using the _double
underscore prefix_ such as `__privatevar`, Python uses name-mangling to effectively make it a
private variable.

Thus, the convention followed is that any variable that is to be used only within the class or
object should begin with an underscore and all other names are public and can be used by other
classes/objects. Remember that this is only a convention and is not enforced by Python (except for
the double underscore prefix).

.Note for C++/Java/C# Programmers
[NOTE]
All class members (including the data members) are _public_ and all the methods are _virtual_ in
Python.

=== Inheritance

One of the major benefits of object oriented programming is *reuse* of code and one of the ways
this is achieved is through the *inheritance* mechanism. Inheritance can be best imagined as
implementing a *type and subtype* relationship between classes.

Suppose you want to write a program which has to keep track of the teachers and students in a
college. They have some common characteristics such as name, age and address. They also have
specific characteristics such as salary, courses and leaves for teachers and, marks and fees for
students.

You can create two independent classes for each type and process them but adding a new common
characteristic would mean adding to both of these independent classes. This quickly becomes
unwieldy.

A better way would be to create a common class called `SchoolMember` and then have the teacher and
student classes _inherit_ from this class i.e. they will become sub-types of this type (class) and
then we can add specific characteristics to these sub-types.

There are many advantages to this approach. If we add/change any functionality in `SchoolMember`,
this is automatically reflected in the subtypes as well. For example, you can add a new ID card
field for both teachers and students by simply adding it to the SchoolMember class. However,
changes in the subtypes do not affect other subtypes. Another advantage is that if you can refer to
a teacher or student object as a `SchoolMember` object which could be useful in some situations
such as counting of the number of school members. This is called *polymorphism* where a sub-type
can be substituted in any situation where a parent type is expected i.e. the object can be treated
as an instance of the parent class.

Also observe that we reuse the code of the parent class and we do not need to repeat it in the
different classes as we would have had to in case we had used independent classes.

The `SchoolMember` class in this situation is known as the *base class* or the *superclass*. The
`Teacher` and `Student` classes are called the *derived classes* or *subclasses*.

We will now see this example as a program (save as `oop_subclass.py`):

[source,python]
--------------------------------------------------
include::programs/oop_subclass.py[]
--------------------------------------------------

Output:

--------------------------------------------------
include::programs/oop_subclass.txt[]
--------------------------------------------------

.How It Works

To use inheritance, we specify the base class names in a tuple following the class name in the
class definition. Next, we observe that the `__init__` method of the base class is explicitly
called using the `self` variable so that we can initialize the base class part of the object. This
is very important to remember - Python does not automatically call the constructor of the base
class, you have to explicitly call it yourself.

We also observe that we can call methods of the base class by prefixing the class name to the
method call and then pass in the `self` variable along with any arguments.

Notice that we can treat instances of `Teacher` or `Student` as just instances of the
`SchoolMember` when we use the `tell` method of the `SchoolMember` class.

Also, observe that the `tell` method of the subtype is called and not the `tell` method of the
`SchoolMember` class. One way to understand this is that Python _always_ starts looking for methods
in the actual type, which in this case it does. If it could not find the method, it starts looking
at the methods belonging to its base classes one by one in the order they are specified in the
tuple in the class definition.

A note on terminology - if more than one class is listed in the inheritance tuple, then it is
called *multiple inheritance*.

The trailing comma is used at the end of the `print` statement in the superclass's `tell()` method
to print a line and allow the next print to continue on the same line. This is a trick to make
`print` not print a `\n` (newline) symbol at the end of the printing.

=== Summary

We have now explored the various aspects of classes and objects as well as the various
terminologies associated with it. We have also seen the benefits and pitfalls of object-oriented
programming. Python is highly object-oriented and understanding these concepts carefully will help
you a lot in the long run.

Next, we will learn how to deal with input/output and how to access files in Python.
