[[oop]]
== 객체 지향 프로그래밍

지금까지 프로그램을 작성할 때, 우리는 데이터를 다루는 명령들의 블록인 함수들의 조합으로 프로그램을
구성하였습니다. 이러한 설계 방식을 _절차 지향_ 프로그래밍 기법이라고 부릅니다. 이와 달리
데이터와 기능을 객체라고 불리우는 것으로 묶어서 프로그램을 구성하는 또 다른 기법이 있습니다.
이것을 _객체 지향_ 프로그래밍 기법이라고 부릅니다. 아마도 여러분의 대부분의 시간 동안 절차 지향
프로그래밍 기법을 통해 프로그램을 작성하게 되겠지만, 큰 프로그램을 작성할 때나 이 기법을
이용하는 것이 더 편리한 문제를 해결해야 할 경우 객체 지향 프로그래밍 기법을 활용할 수 있습니다.

객체 지향 프로그래밍에서는 클래스와 객체라는 두 가지 주인공이 있습니다. *클래스*는 새로운 _형식_
을 정의하는 것이며, *객체*는 클래스의 *인스턴스* 를 의미하는 것입니다. 이것을 다시 표현하면
여러분이 `int` 라는 형식의 변수를 만들 수 있다는 것으로, 이것은 곧 정수형을 저장하는 변수는
`int` 클래스의 인스턴스(객체)를 변수에 할당하는 것이라고도 말할 수 있습니다.

.정적 언어 프로그래머들을 위한 주석
[NOTE]
--
파이썬에서는 정수형조차도 객체로 다루어집니다 (`int` 클래스의 객체입니다). C++이나 Java
(버전 1.5 미만)처럼 정수형이 자체 기본 형식들 중 하나로 다루어지는 것과는 다릅니다.

`help(int)` 를 입력하여 정수형 클래스에 대해 좀 더 자세히 알아보시기 바랍니다.

C# 이나 Java 1.5 프로그래머들은 아마 이것이 _boxing 과 unboxing_ 과 비슷하다는 것을
눈치채셨을 것입니다.
--

객체는 그 객체에 _내장된_ 일반적인 변수들을 사용하여 데이터를 저장할 수 있습니다. 이 때 객체 혹은
클래스에 소속된 변수들을 *필드(field)* 라고 부릅니다. 객체는 또한 _내장된_ 함수를 이용하여 어떤
기능을 갖도록 할 수 있는데 이것을 클래스의 *메소드(method)* 라고 부릅니다. 이러한 명칭을
구별하여 부르는 것은 중요한데, 이는 일반적인 변수와 함수와 달리 이들은 클래스나 객체에 소속되어
있는 대상들이기 때문입니다. 또, 이러한 필드와 메소드들을 통틀어 클래스의 *속성(attribute)* 이라
부릅니다.

필드는 두 가지 종류가 있습니다. 하나는 클래스의 인스턴스/객체에 내장되어 있는 것이고, 또 하나는
클래스 자체에 내장되어 있는 것입니다. 각각을 *인스턴스 변수* 와 *클래스 변수* 라 부릅니다.

클래스는 `class` 키워드를 통해 생성됩니다. 클래스의 필드와 메소드는 그 아래 들여쓰기 된 블록에
차례로 정의됩니다.

[[self]]
=== +self+ 에 대하여

클래스 메소드는 일반적인 함수와 딱 한 가지 다른 점이 있는데, 그것은 메소드의 경우 매개 변수의
목록에 항상 추가로 한 개의 변수가 맨 앞에 추가되어야 한다는 점입니다. 또한 메소드를 호출할 때
이 변수에는 우리가 직접 값을 넘겨주지 *않으며*, 대신 파이썬이 자동으로 값을 할당합니다.
이 변수에는 현재 객체 _자신의_ 참조가 할당되며, 일반적으로 `self` 라 이름을 짓습니다.

이 변수의 이름은 마음대로 지을 수 있지만, `self` 라는 이름을 사용할 것을 _강력히 권합니다_.
이것은 어떤 약속으로, 다른 이름을 사용하는 것은 다른 프로그래머들에게 좀 눈살을 찌푸려지게 하는
일이 될 수 있기 때문입니다. `self`라는 표준적인 이름을 사용하면 여러분의 프로그램을 읽는
사람들로부터 이것이 그것을 의마함을 쉽게 알아보게 할 수 있고, 심지어 특별한 IDE (Integrated
Development Environment)를 사용하는 사람들도 이를 쉽게 알아볼 수 있는 등 여러 장점이 있습니다.

.C++/Java/C# 프로그래머를 위한 주석
[NOTE]
파이썬의 `self` 는 C++ 의 `this` 포인터와 같은 것이며, Java와 C# 의 `this` 참조와 같습니다.

아마 여러분은 파이썬이 `self` 에 어떻게 값을 할당하는 것인지 그리고 정말 값을 직접 할당할 필요가
없는지 궁금할 것입니다. 이해를 돕기 위해 예를 하나 들어 보겠습니다. 여러분이 `MyClass` 라는
클래스를 생성했고, 이 클래스의 객체를 `myobject` 라는 이름으로 생성했다고 해 봅시다. 이제 이
객체의 메소드를 호출할 때는 `myobject.method(arg1, arg2)` 와 같이 하며, 이것은 파이썬에 의해
자동적으로 `MyClass.method(myobject, arg1, arg2)` 의 형태로 바뀌게 됩니다. 이것이 `self`
에 대한 모든 것입니다.

또한 이것은 아무런 인수도 넘겨받지 않는 메소드를 정의할 때에도, `self` 라는 하나의 인수를
추가해 주어야 한다는 것을 의미합니다.

[[class]]
=== Classes

The simplest class possible is shown in the following example (save as `oop_simplestclass.py`).

[source,python]
--------------------------------------------------
include::programs/oop_simplestclass.py[]
--------------------------------------------------

Output:

--------------------------------------------------
include::programs/oop_simplestclass.txt[]
--------------------------------------------------

.How It Works

We create a new class using the `class` statement and the name of the class. This is followed by an
indented block of statements which form the body of the class. In this case, we have an empty block
which is indicated using the `pass` statement.

Next, we create an object/instance of this class using the name of the class followed by a pair of
parentheses. (We will learn <<init,more about instantiation>> in the next section). For our
verification, we confirm the type of the variable by simply printing it. It tells us that we have
an instance of the `Person` class in the `__main__` module.

Notice that the address of the computer memory where your object is stored is also printed. The
address will have a different value on your computer since Python can store the object wherever it
finds space.

[[methods]]
=== Methods

We have already discussed that classes/objects can have methods just like functions except that we
have an extra `self` variable. We will now see an example (save as `oop_method.py`).

[source,python]
--------------------------------------------------
include::programs/oop_method.py[]
--------------------------------------------------

Output:

--------------------------------------------------
include::programs/oop_method.txt[]
--------------------------------------------------

.How It Works

Here we see the `self` in action. Notice that the `say_hi` method takes no parameters but still has
the `self` in the function definition.

[[init]]
=== The `__init__` method

There are many method names which have special significance in Python classes. We will see the
significance of the `__init__` method now.

The `__init__` method is run as soon as an object of a class is instantiated. The method is useful
to do any *initialization* you want to do with your object. Notice the double underscores both at
the beginning and at the end of the name.

Example (save as `oop_init.py`):

[source,python]
--------------------------------------------------
include::programs/oop_init.py[]
--------------------------------------------------

Output:

--------------------------------------------------
include::programs/oop_init.txt[]
--------------------------------------------------

.How It Works

Here, we define the `__init__` method as taking a parameter `name` (along with the usual `self`).
Here, we just create a new field also called `name`. Notice these are two different variables even
though they are both called 'name'. There is no problem because the dotted notation `self.name`
means that there is something called "name" that is part of the object called "self" and the other
`name` is a local variable. Since we explicitly indicate which name we are referring to, there is
no confusion.

Most importantly, notice that we do not explicitly call the `__init__` method but pass the
arguments in the parentheses following the class name when creating a new instance of the
class. This is the special significance of this method.

Now, we are able to use the `self.name` field in our methods which is demonstrated in the `sayHi`
method.

[[class_obj_vars]]
=== Class And Object Variables

We have already discussed the functionality part of classes and objects (i.e. methods), now let us
learn about the data part. The data part, i.e. fields, are nothing but ordinary variables that are
_bound_ to the *namespaces* of the classes and objects. This means that these names are valid
within the context of these classes and objects only. That's why they are called _name spaces_.

There are two types of _fields_ - class variables and object variables which are classified
depending on whether the class or the object _owns_ the variables respectively.

*Class variables* are shared - they can be accessed by all instances of that class. There is only
one copy of the class variable and when any one object makes a change to a class variable, that
change will be seen by all the other instances.

*Object variables* are owned by each individual object/instance of the class. In this case, each
object has its own copy of the field i.e. they are not shared and are not related in any way to the
field by the same name in a different instance. An example will make this easy to understand (save
as `oop_objvar.py`):

[source,python]
--------------------------------------------------
include::programs/oop_objvar.py[]
--------------------------------------------------

Output:

--------------------------------------------------
include::programs/oop_objvar.txt[]
--------------------------------------------------

.How It Works

This is a long example but helps demonstrate the nature of class and object variables. Here,
`population` belongs to the`Robot` class and hence is a class variable. The `name` variable belongs
to the object (it is assigned using `self`) and hence is an object variable.

Thus, we refer to the `population` class variable as `Robot.population` and not as
`self.population`. We refer to the object variable `name` using `self.name` notation in the methods
of that object. Remember this simple difference between class and object variables. Also note that
an object variable with the same name as a class variable will hide the class variable!

Instead of `Robot.population`, we could have also used `self.__class__.population` because every
object refers to it's class via the `self.__class__` attribute.

The `how_many` is actually a method that belongs to the class and not to the object. This means we
can define it as either a `classmethod` or a `staticmethod` depending on whether we need to know
which class we are part of. Since we refer to a class variable, let's use `classmethod`.

We have marked the `how_many` method as a class method using a <<decorator,decorator>>.

Decorators can be imagined to be a shortcut to calling a wrapper function, so applying the
`@classmethod` decorator is same as calling:

[source,python]
--------------------------------------------------
how_many = classmethod(how_many)
--------------------------------------------------

Observe that the `__init__` method is used to initialize the `Robot` instance with a name. In this
method, we increase the `population` count by 1 since we have one more robot being added. Also
observe that the values of `self.name` is specific to each object which indicates the nature of
object variables.

Remember, that you must refer to the variables and methods of the same object using the `self`
*only*. This is called an *attribute reference*.

In this program, we also see the use of *docstrings* for classes as well as methods. We can access
the class docstring at runtime using `Robot.__doc__` and the method docstring as
`Robot.say_hi.__doc__`

In the `die` method, we simply decrease the `Robot.population` count by 1.

All class members are public. One exception: If you use data members with names using the _double
underscore prefix_ such as `__privatevar`, Python uses name-mangling to effectively make it a
private variable.

Thus, the convention followed is that any variable that is to be used only within the class or
object should begin with an underscore and all other names are public and can be used by other
classes/objects. Remember that this is only a convention and is not enforced by Python (except for
the double underscore prefix).

.Note for C++/Java/C# Programmers
[NOTE]
All class members (including the data members) are _public_ and all the methods are _virtual_ in
Python.

=== Inheritance

One of the major benefits of object oriented programming is *reuse* of code and one of the ways
this is achieved is through the *inheritance* mechanism. Inheritance can be best imagined as
implementing a *type and subtype* relationship between classes.

Suppose you want to write a program which has to keep track of the teachers and students in a
college. They have some common characteristics such as name, age and address. They also have
specific characteristics such as salary, courses and leaves for teachers and, marks and fees for
students.

You can create two independent classes for each type and process them but adding a new common
characteristic would mean adding to both of these independent classes. This quickly becomes
unwieldy.

A better way would be to create a common class called `SchoolMember` and then have the teacher and
student classes _inherit_ from this class i.e. they will become sub-types of this type (class) and
then we can add specific characteristics to these sub-types.

There are many advantages to this approach. If we add/change any functionality in `SchoolMember`,
this is automatically reflected in the subtypes as well. For example, you can add a new ID card
field for both teachers and students by simply adding it to the SchoolMember class. However,
changes in the subtypes do not affect other subtypes. Another advantage is that if you can refer to
a teacher or student object as a `SchoolMember` object which could be useful in some situations
such as counting of the number of school members. This is called *polymorphism* where a sub-type
can be substituted in any situation where a parent type is expected i.e. the object can be treated
as an instance of the parent class.

Also observe that we reuse the code of the parent class and we do not need to repeat it in the
different classes as we would have had to in case we had used independent classes.

The `SchoolMember` class in this situation is known as the *base class* or the *superclass*. The
`Teacher` and `Student` classes are called the *derived classes* or *subclasses*.

We will now see this example as a program (save as `oop_subclass.py`):

[source,python]
--------------------------------------------------
include::programs/oop_subclass.py[]
--------------------------------------------------

Output:

--------------------------------------------------
include::programs/oop_subclass.txt[]
--------------------------------------------------

.How It Works

To use inheritance, we specify the base class names in a tuple following the class name in the
class definition. Next, we observe that the `__init__` method of the base class is explicitly
called using the `self` variable so that we can initialize the base class part of the object. This
is very important to remember - Python does not automatically call the constructor of the base
class, you have to explicitly call it yourself.

We also observe that we can call methods of the base class by prefixing the class name to the
method call and then pass in the `self` variable along with any arguments.

Notice that we can treat instances of `Teacher` or `Student` as just instances of the
`SchoolMember` when we use the `tell` method of the `SchoolMember` class.

Also, observe that the `tell` method of the subtype is called and not the `tell` method of the
`SchoolMember` class. One way to understand this is that Python _always_ starts looking for methods
in the actual type, which in this case it does. If it could not find the method, it starts looking
at the methods belonging to its base classes one by one in the order they are specified in the
tuple in the class definition.

A note on terminology - if more than one class is listed in the inheritance tuple, then it is
called *multiple inheritance*.

The trailing comma is used at the end of the `print` statement in the superclass's `tell()` method
to print a line and allow the next print to continue on the same line. This is a trick to make
`print` not print a `\n` (newline) symbol at the end of the printing.

=== Summary

We have now explored the various aspects of classes and objects as well as the various
terminologies associated with it. We have also seen the benefits and pitfalls of object-oriented
programming. Python is highly object-oriented and understanding these concepts carefully will help
you a lot in the long run.

Next, we will learn how to deal with input/output and how to access files in Python.
