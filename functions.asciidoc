[[functions]]
== 함수

함수는 재사용 가능한 프로그램의 조각을 말합니다. 이것은 특정 구역의 명령어 덩어리를
묶어 이름을 짓고, 그 이름을 프로그램 어디에서건 사용함으로써 그 구역에 포함된 명령어들을
몇번이고 다시 실행할 수 있게 하는 것입니다. 이를 보고 함수를 *호출한다* 라고 합니다.
사실 우리는 이미 앞에서 `len` 이나 `range` 와 같은 많은 내장 함수들을 사용해 왔습니다.

이러한 함수라는 것은 프로그램을 작성할 때 아마도 *가장* 중요한 단위가 될 것입니다 (어떤
프로그래밍 언어에서라도). 따라서 이 챕터에서는 함수라는 것을 다양한 관점에서 살펴보도록
하겠습니다.

함수는 `def` 키워드를 통해 정의됩니다. `def` 뒤에는 함수의 *식별자* 이름을 입력하고,
괄호로 감싸여진 함수에서 사용될 인자(arguments)의 목록을 입력하며 마지막으로 콜론을 입력하면
함수의 정의가 끝납니다. 새로운 구역이 시작되는 다음 줄부터는 이 함수에서 사용될 명령어들을
입력해 줍니다. 복잡해 보이지만, 아래 예제를 통해 함수를 정의하는 것이 얼마나 간단한지 알아봅시다.

예제 (`function1.py` 로 저장합니다):

[source,python]
--------------------------------------------------
include::programs/function1.py[]
--------------------------------------------------

출력 예시:

--------------------------------------------------
include::programs/function1.txt[]
--------------------------------------------------

.동작 원리

여기에서는 위에서 설명한 문법을 이용하여 `say_hello` 라는 함수를 정의하였습니다.
이 함수는 어떤 인자도 넘겨받지 않으므로, 괄호 내에 매개 변수를 정의하지 않습니다.
함수의 인수란 함수로 넘겨지는 입력값들을 말하며, 함수는 이 값을 처리하여 결과를 넘겨줍니다.

함수를 두 번 호출하는 것은 같은 코드를 두 번 작성하는 것과 같은 효과를 가진다는 것을 알아두세요.

[[function_parameters]]
=== 함수와 매개 변수

함수를 정의할 때 매개 변수를 지정할 수 있습니다. 매개 변수란 함수로 넘겨지는 값들의 이름을 말하며,
함수는 이 값들을 이용해 무언가를 *할* 수 있습니다. 매개 변수는 변수와 거의 같이 취급되지만,
매개 변수의 값들은 함수가 호출되어질때 넘겨받은 값들로 채워지며 함수가 실행되는 시점에서는 이미
할당이 완료되어 있다는 점이 다릅니다.

매개 변수는 함수를 정의할 때 괄호 안에 쉼표로 구분하여 지정합니다. 함수를 호출할 때에는, 동일한
방법으로 함수에 값을 넘겨 줍니다. 이 때 함수를 정의할 때 주어진 이름을 *매개 변수* 라 부르고,
함수에 넘겨준 값들을 *인자* 라 부릅니다.

예제 (`function_param.py` 로 저장하세요):

[source,python]
--------------------------------------------------
include::programs/function_param.py[]
--------------------------------------------------

출력 예시:

--------------------------------------------------
include::programs/function_param.txt[]
--------------------------------------------------

.동작 원리

여기서는 두 매개 변수 `a` 와 `b` 를 사용하는 `print_max` 라는 함수를 정의합니다. 그리고 간단한
`if...else` 문을 이용하여 크기를 비교하고 둘 중에 더 큰 값을 출력합니다.

`print_max` 함수를 처음 호출할 때에는 값을 직접 인자로 입력하여 넘겨주었습니다. 반면 두 번째
호출시에는 변수를 인자로 입력하여 주었습니다. 이것은 `print_max(x, y)` 는 변수 `x` 에 지정된
값을 변수 `a` 에 입력해 주고 변수 `y` 의 값을 변수 `b` 에 입력해 주는 것을 의미합니다. 따라서 
이 함수는 두 경우 모두 동일하게 동작하게 됩니다.

[[local_variables]]
=== 지역 변수

여러분이 정의한 함수 안에서 변수를 선언하고 사용할 경우, 함수 밖에 있는 같은 이름의 변수들과
함수 안에 있는 변수들과는 서로 연관이 없습니다. 이러한 변수들을 함수의 *지역(local)* 변수라고
하며, 그 범위를 변수의 *스코프(scope)* 라고 부릅니다. 모든 변수들은 변수가 정의되는 시점에서의
블록을 스코프로 가지게 됩니다.

예제 (`function_local.py` 로 저장하세요):

[source,python]
--------------------------------------------------
include::programs/function_local.py[]
--------------------------------------------------

출력 예시:

--------------------------------------------------
include::programs/function_local.txt[]
--------------------------------------------------

.동작 원리

먼저 함수의 첫번째 줄에서 *x* 라는 이름을 가진 변수에 담긴 *값*을 출력합니다. 이 때 함수 정의
위에 정의된 변수의 값을 함수의 매개 변수 x로 넘겨받은 값이 출력됩니다.

다음으로, `x` 에 값 `2` 를 대입합니다. 그러나 `x` 는 함수의 지역 변수이므로, 함수 안에서 `x` 의
값이 대입된 값으로 변하는 반면 메인 블록의 `x` 는 변하지 않고 그대로 남아 있습니다.

프로그램에서 사용된 마지막 `print` 문을 통해 메인 블록의 `x` 값을 출력해 보면, 그 이전에 호출된
함수 안에서 시행된 지역 변수값의 변화가 적용되지 않았음을 확인할 수 있습니다.

[[the_global_statement]]
=== +global+ 문

함수나 클래스 내부에서 상위 블록에서 선언된 변수의 값을 변경하고 싶을 경우, 파이썬에게 이 변수를
앞으로 지역 변수가 아닌 *전역(global)* 변수로 사용할 것임을 알려 주어야 합니다. 이때 `global` 문을
이용합니다. `global` 문을 사용하지 않으면, 함수 외부에서 선언된 변수의 값을 함수 내부에서 변경할
수 없습니다.

함수 안에서 동일한 이름으로 선언된 변수가 없을 경우, 함수 밖의 변수값을 함수 안에서 읽고 변경할 수도
있습니다. 그러나, 이것은 프로그램을 읽을 때 변수가 어디서 어떻게 선언되었는지 파악하기 힘들게 만들기
때문에 추천할만한 방법이 아니며, 가능한 이런 경우를 피하시기 바랍니다. `global` 문을 사용하면 그 블록의
밖에서 그 변수가 선언되어 있음을 알려 주므로 좀 더 프로그램이 좀 더 명확해집니다.

예제 (`function_global.py` 로 저장하세요):

[source,python]
--------------------------------------------------
include::programs/function_global.py[]
--------------------------------------------------

출력 예시:

--------------------------------------------------
include::programs/function_global.txt[]
--------------------------------------------------

.동작 원리

`global` 문을 통해 `x` 가 전역 변수임을 파이썬에게 알려 줍니다. 따라서, 이후로 `x` 에 값을 대입하면
메인 블록의 `x` 값 또한 변경됩니다.

하나의 `global` 문으로 여러 개의 전역 변수를 동시에 지정해 줄 수도 있습니다. `global x, y, z`
와 같이 하면 됩니다.

[[default_argument_values]]
=== 기본 인수값

어떤 특별한 경우, 함수를 호출할 때 인수를 *선택적으로* 넘겨주게 하여 사용자가 값을 넘겨주지
않으면 자동으로 기본값을 사용하도록 하는 것이 편할 때가 있습니다. 이런 경우, 기본 인수값을
지정하면 됩니다. 함수를 선언할 때 원하는 매개 변수 뒤에 대입 연산자 (`=`)와 기본값을
입력하여 기본 인수값을 지정합니다.

이 때, 기본 인수값은 반드시 상수이어야 합니다. 좀 더 정확히 말하자면, 불변값이어야 합니다.
불변값에 대해서는 뒤 챕터에서 다룰 것입니다. 일단 지금은, 그래야 한다는 것만 기억해 두기 바랍니다.

예제 (`function_default.py` 로 저장하세요):

[source,python]
--------------------------------------------------
include::programs/function_default.py[]
--------------------------------------------------

출력 예시:

--------------------------------------------------
include::programs/function_default.txt[]
--------------------------------------------------

.동작 원리

함수 `say` 는 지정된 숫자 만큼 문자열을 반복하여 출력하는 합수입니다. 숫자를 지정하지 않으면,
기본값이 적용되어, 문자열이 한 번 출력됩니다. 이 결과는 매개 변수 `times` 의 기본 인수값을 `1` 로
지정해 줌으로써 얻어집니다.

프로그램에서 처음 `say` 를 호출할 때에는 함수에 문자열만 넘겨 주어 한번 출력하게 합니다. 두 번째
호출에서는 문자열과 인수 `5` 를 넘겨 주어 함수가 문자열을 5번 반복하여 말(*say*)하게 합니다.

[주의]
--
매개 변수 목록에서 마지막에 있는 매개 변수들에만 기본 인수값을 지정해 줄 수 있습니다. 즉,
기본 인수값을 지정하지 않은 매개 변수의 앞에 위치한 매개 변수에만 기본 인수값을 지정할 수 없습니다.

이것은 함수 를 호출할 때 매개 변수의 위치에 맞춰서 값이 지정되기 때문입니다. 예를 들어, `def func(a,
b=5)` 는 옳은 함수 정의이지만 `def func(a=5, b)` 는 *옳지 않습니다*.
--

[[keyword_arguments]]
=== 키워드 인수

If you have some functions with many parameters and you want to specify only some of them, then you
can give values for such parameters by naming them - this is called *keyword arguments* - we use
the name (keyword) instead of the position (which we have been using all along) to specify the
arguments to the function.

There are two advantages - one, using the function is easier since we do not need to worry about
the order of the arguments. Two, we can give values to only those parameters to which we want to,
provided that the other parameters have default argument values.

Example (save as `function_keyword.py`):

[source,python]
--------------------------------------------------
include::programs/function_keyword.py[]
--------------------------------------------------

Output:

--------------------------------------------------
include::programs/function_keyword.txt[]
--------------------------------------------------

.How It Works

The function named `func` has one parameter without a default argument value, followed by two
parameters with default argument values.

In the first usage, `func(3, 7)`, the parameter `a` gets the value `3`, the parameter `b` gets the
value `7` and `c` gets the default value of `10`.

In the second usage `func(25, c=24)`, the variable `a` gets the value of 25 due to the position of
the argument. Then, the parameter `c` gets the value of `24` due to naming i.e. keyword
arguments. The variable `b` gets the default value of `5`.

In the third usage `func(c=50, a=100)`, we use keyword arguments for all specified values. Notice
that we are specifying the value for parameter `c` before that for `a` even though `a` is defined
before `c` in the function definition.

[[varargs_parameters]]
=== VarArgs parameters

Sometimes you might want to define a function that can take _any_ number of parameters,
i.e. **var**iable number of **arg**uments, this can be achieved by using the stars (save as
`function_varargs.py`):

[source,python]
--------------------------------------------------
include::programs/function_varargs.py[]
--------------------------------------------------

Output:

--------------------------------------------------
include::programs/function_varargs.txt[]
--------------------------------------------------

.How It Works

When we declare a starred parameter such as `*param`, then all the positional arguments from that
point till the end are collected as a tuple called 'param'.

Similarly, when we declare a double-starred parameter such as `**param`, then all the keyword
arguments from that point till the end are collected as a dictionary called 'param'.

We will explore tuples and dictionaries in a <<data_structures,later chapter>>.

[[the_return_statement]]
=== The +return+ statement

The `return` statement is used to *return* from a function i.e. break out of the function. We can
optionally *return a value* from the function as well.

Example (save as `function_return.py`):

[source,python]
--------------------------------------------------
include::programs/function_return.py[]
--------------------------------------------------

Output:

--------------------------------------------------
include::programs/function_return.txt[]
--------------------------------------------------

.How It Works

The `maximum` function returns the maximum of the parameters, in this case the numbers supplied to
the function. It uses a simple `if..else` statement to find the greater value and then *returns*
that value.

Note that a `return` statement without a value is equivalent to `return None`. `None` is a special
type in Python that represents nothingness. For example, it is used to indicate that a variable has
no value if it has a value of `None`.

Every function implicitly contains a `return None` statement at the end unless you have written
your own `return` statement. You can see this by running `print some_function()` where the function
`some_function` does not use the `return` statement such as:

[source,python]
--------------------------------------------------
def some_function():
    pass
--------------------------------------------------

The `pass` statement is used in Python to indicate an empty block of statements.

TIP: There is a built-in function called `max` that already implements the 'find maximum'
functionality, so use this built-in function whenever possible.

[[docstrings]]
=== DocStrings

Python has a nifty feature called *documentation strings*, usually referred to by its shorter name
*docstrings*. DocStrings are an important tool that you should make use of since it helps to
document the program better and makes it easier to understand. Amazingly, we can even get the
docstring back from, say a function, when the program is actually running!

Example (save as `function_docstring.py`):

[source,python]
--------------------------------------------------
include::programs/function_docstring.py[]
--------------------------------------------------

Output:

--------------------------------------------------
include::programs/function_docstring.txt[]
--------------------------------------------------

.동작 원리

함수에 포함된 첫 논리적 명령행의 문자열은 함수의 *DocString* 이라고 불리우는 것입니다.
여기에서 설명하는 DocString은 <<module,모듈>> 과 <<oop,클래스>> 에도 똑같이 적용됩니다.
각각에 대해서는 각 챕터에서 좀 더 자세히 알아보도록 하겠습니다.

DocString은 일반적으로 첫째줄의 첫문자는 대문자로, 마지막 문자는 마침표로 끝나도록
작성합니다. 그리고 두번째 줄은 비워 두고, 세번째 줄부터는 이것이 어떤 기능을 하는지에 대해
상세하게 작성합니다. 저는 앞으로 여러분이 함수의 DocString를 작성할 때 이 규칙을 따르기를
*강력히 권합니다*.

`print_max` 함수의 DocString은 함수의 `__doc__` 속성을 통해 접근할 수 있습니다 (밑줄이 *두 개*
임을 다시한번 확인하세요). `__doc__` 은 함수 객체가 갖고 있는 기본 속성입니다. 파이썬에서는
함수를 포함한 *모든* 것이 객체로 다루어진다는 점을 기억하세요. 이에 대해서는 <<oop,클래스>>
챕터에서 좀 더 자세히 알아볼 것입니다.

파이썬에서 `help()` 를 이용해 보셨다면, 여러분은 이미 DocString을 본 적이 있는 것입니다!
`help()` 가 하는 일은 주어진 대상의 `__doc__` 속성을 가져와 화면에 보여주는 것 뿐입니다.
따라서 위에서 만든 함수에 대해서도 마찬가지로 동작합니다. 여러분의 프로그램에 `help(print_max)`
라고 한 줄 추가해 보시기 바랍니다. `help` 창을 닫으려면  `q` 키를 누르세요.

이를 이용하여 여러분의 프로그램에 대한 명세서를 자동으로 만들어주는 프로그램들이 있습니다.
따라서, 저는 여러분이 어떤 함수를 작성하시던지 DocString을 작성할 것을 *강력히 권합니다*.
파이썬과 함께 설치되는 `pydoc` 또한 `help()` 와 비슷한 방법으로 DocString을 이용하여 동작합니다.

=== Summary

We have seen so many aspects of functions but note that we still haven't covered all aspects of
them. However, we have already covered most of what you'll use regarding Python functions on an
everyday basis.

Next, we will see how to use as well as create Python modules.
