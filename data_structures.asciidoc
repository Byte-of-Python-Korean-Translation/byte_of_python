[[data_structures]]
== 자료 구조

자료 구조란 간단하게, 어떤 *자료*를 담는 *구조*를 말합니다. 다른 말로 하면, 서로 연관있는 어떤
자료들의 집합을 저장하는 데 사용됩니다.

파이썬에는 네 종류의 자료 구조가 있는데, 각각 _리스트, 튜플, 사전, 집합_입니다. 이제 앞으로
각각의 사용법에 대해 알아보고 또 각각이 얼마나 편리한지 확인해보도록 하겠습니다.

[[list]]
=== 리스트

리스트란 순서대로 정리된 항목들을 담고 있는 자료 구조입니다. 즉, 리스트에는 항목의 *목록*을
저장할 수 있습니다. 이것은 쉽게 말하자면 장 보러 갈 때 적는 일종의 장바구니 목록 같은 것인데,
아마도 여러분은 각 품목들을 한줄 한줄 적겠지만 파이썬에서는 쉼표로 각 항목을 구분한다는 것만
다릅니다.

리스트를 정의할 때는 대괄호 `[]` 를 이용해서 파이썬에게 이것이 리스트를 의미한다는 것을 알려 줍니다.
한번 리스트를 만들어 두면 여기에 새로운 항목을 추가하거나 삭제할 수 있으며, 특정 항목이 존재하는지
검색할 수도 있습니다. 이 때 항목을 추가 및 삭제가 가능하다는 것을 *비정적(mutable)*이라고 하며,
리스트는 비정적 자료구조로 내부 항목을 변경할 수 있습니다.

=== 객체와 클래스에 대한 간단한 소개

객체와 클래스에 대해서는 좀 더 나중에 다룰 예정이지만, 여기서 여러분이 리스트에 대해 좀 더 잘
이해하실 수 있도록 이에 대한 간단한 소개를 하도록 하겠습니다. 이들에 대해서는 <<oop,뒤 챕터>>에서 
좀 더 자세하게 다루겠습니다.

리스트는 객체와 클래스가 사용된 한 예입니다. 변수 `i` 를 선언하고 예를 들어 `5` 라는 값을 할당해
주는 것은, `int` 라는 *클래스*(또는 타입)의 *객체*(또는 인스턴스) `i` 를 만드는 것입니다.
이에 대해 좀 더 자세히 알아보시려면 `help(int)` 를 읽어보시기 바랍니다.

클래스는 *메소드*를 가질 수 있는데, 여기서 메소드란 그 클래스 내에 정의된 고유의 내장 함수들을
말합니다. 또 이러한 내장 함수들은 클래스로 객체를 생성했을 때에야 비로소 사용할 수 있습니다. 예를 들어,
파이썬은 `list` 클래스에 `append` 라는 메소드를 제공하며 이는 리스트의 마지막에 항목을 한 개 추가할
때 사용되는 메소드입니다. 즉 `mylist.append('an item')` 라 하면 리스트 `mylist` 의 마지막에 해당
문자열을 추가해 줍니다. 이 때 객체의 메소드에 접근할 때에도 마침표를 이용한다는 점을 기억하세요.

또 클래스는 *필드*를 가질 수 있는데 이것은 단순히 그 클래스 내에 정의된 변수들을 의미합니다.
메소드와 마찬가지로 이러한 변수들은 클래스로 객체를 생성했을 때에야 비로소 사용할 수 있습니다.
필드도 메소드와 마찬가지로 마침표를 이용하여 접근합니다. 예를 들면 `mylist.field` 와 같습니다.

예제 (`ds_using_list.py` 로 저장하세요):

[source,python]
--------------------------------------------------
include::programs/ds_using_list.py[]
--------------------------------------------------

출력 예시:

--------------------------------------------------
include::programs/ds_using_list.txt[]
--------------------------------------------------

.동작 원리

변수 `shoplist` 는 

is a shopping list for someone who is going to the market. In `shoplist`,
we only store strings of the names of the items to buy but you can add _any kind of object_ to a
list including numbers and even other lists.

We have also used the `for..in` loop to iterate through the items of the list. By now, you must
have realised that a list is also a sequence. The speciality of sequences will be discussed in a
<<sequence,later section>>.

Notice the use of the trailing comma in the `print` statement to indicate that we want to end the
output with a space instead of the usual line break. Think of the comma as telling Python that we
have more items to print on the same line.

Next, we add an item to the list using the `append` method of the list object, as already discussed
before. Then, we check that the item has been indeed added to the list by printing the contents of
the list by simply passing the list to the `print` statement which prints it neatly.

Then, we sort the list by using the `sort` method of the list. It is important to understand that
this method affects the list itself and does not return a modified list - this is different from
the way strings work. This is what we mean by saying that lists are _mutable_ and that strings are
_immutable_.

Next, when we finish buying an item in the market, we want to remove it from the list. We achieve
this by using the `del` statement. Here, we mention which item of the list we want to remove and
the `del` statement removes it from the list for us.  We specify that we want to remove the first
item from the list and hence we use `del shoplist[0]` (remember that Python starts counting from
0).

If you want to know all the methods defined by the list object, see `help(list)` for details.

[[tuple]]
=== Tuple

Tuples are used to hold together multiple objects. Think of them as similar to lists, but without
the extensive functionality that the list class gives you. One major feature of tuples is that they
are *immutable* like strings i.e. you cannot modify tuples.

Tuples are defined by specifying items separated by commas within an optional pair of parentheses.

Tuples are usually used in cases where a statement or a user-defined function can safely assume
that the collection of values i.e. the tuple of values used will not change.

Example (save as `ds_using_tuple.py`):

[source,python]
--------------------------------------------------
include::programs/ds_using_tuple.py[]
--------------------------------------------------

Output:

--------------------------------------------------
include::programs/ds_using_tuple.txt[]
--------------------------------------------------

.How It Works

The variable `zoo` refers to a tuple of items. We see that the `len` function can be used to get
the length of the tuple. This also indicates that a tuple is a <<sequence,sequence>> as well.

We are now shifting these animals to a new zoo since the old zoo is being closed. Therefore, the
`new_zoo` tuple contains some animals which are already there along with the animals brought over
from the old zoo. Back to reality, note that a tuple within a tuple does not lose its identity.

We can access the items in the tuple by specifying the item's position within a pair of square
brackets just like we did for lists. This is called the _indexing_ operator. We access the third
item in `new_zoo` by specifying `new_zoo[2]` and we access the third item within the third item in
the `new_zoo` tuple by specifying `new_zoo[2][2]`. This is pretty simple once you've understood the
idiom.

.Tuple with 0 or 1 items
[NOTE]
An empty tuple is constructed by an empty pair of parentheses such as `myempty = ()`. However, a
tuple with a single item is not so simple. You have to specify it using a comma following the first
(and only) item so that Python can differentiate between a tuple and a pair of parentheses
surrounding the object in an expression i.e. you have to specify `singleton = (2 , )` if you mean
you want a tuple containing the item `2`.

.Note for Perl programmers
[NOTE]
A list within a list does not lose its identity i.e. lists are not flattened as in Perl. The same
applies to a tuple within a tuple, or a tuple within a list, or a list within a tuple, etc. As far
as Python is concerned, they are just objects stored using another object, that's all.

[[dictionary]]
=== Dictionary

A dictionary is like an address-book where you can find the address or contact details of a person
by knowing only his/her name i.e. we associate *keys* (name) with *values* (details). Note that the
key must be unique just like you cannot find out the correct information if you have two persons
with the exact same name.

Note that you can use only immutable objects (like strings) for the keys of a dictionary but you
can use either immutable or mutable objects for the values of the dictionary.  This basically
translates to say that you should use only simple objects for keys.

Pairs of keys and values are specified in a dictionary by using the notation `d = {key1 : value1,
key2 : value2 }`. Notice that the key-value pairs are separated by a colon and the pairs are
separated themselves by commas and all this is enclosed in a pair of curly braces.

Remember that key-value pairs in a dictionary are not ordered in any manner. If you want a
particular order, then you will have to sort them yourself before using it.

The dictionaries that you will be using are instances/objects of the `dict` class.

Example (save as `ds_using_dict.py`):

[source,python]
--------------------------------------------------
include::programs/ds_using_dict.py[]
--------------------------------------------------

Output:

--------------------------------------------------
include::programs/ds_using_dict.txt[]
--------------------------------------------------

.How It Works

We create the dictionary `ab` using the notation already discussed. We then access key-value pairs
by specifying the key using the indexing operator as discussed in the context of lists and
tuples. Observe the simple syntax.

We can delete key-value pairs using our old friend - the `del` statement. We simply specify the
dictionary and the indexing operator for the key to be removed and pass it to the `del`
statement. There is no need to know the value corresponding to the key for this operation.

Next, we access each key-value pair of the dictionary using the `items` method of the dictionary
which returns a list of tuples where each tuple contains a pair of items - the key followed by the
value. We retrieve this pair and assign it to the variables `name` and `address` correspondingly
for each pair using the `for..in` loop and then print these values in the for-block.

We can add new key-value pairs by simply using the indexing operator to access a key and assign
that value, as we have done for Guido in the above case.

We can check if a key-value pair exists using the `in` operator.

For the list of methods of the `dict` class, see `help(dict)`.

.Keyword Arguments and Dictionaries
[TIP]
If you have used keyword arguments in your functions, you have already used dictionaries! Just
think about it - the key-value pair is specified by you in the parameter list of the function
definition and when you access variables within your function, it is just a key access of a
dictionary (which is called the _symbol table_ in compiler design terminology).

[[sequence]]
=== Sequence

Lists, tuples and strings are examples of sequences, but what are sequences and what is so special
about them?

The major features are *membership tests*, (i.e. the `in` and `not in` expressions) and *indexing
operations*, which allow us to fetch a particular item in the sequence directly.

The three types of sequences mentioned above - lists, tuples and strings, also have a *slicing*
operation which allows us to retrieve a slice of the sequence i.e. a part of the sequence.

Example (save as `ds_seq.py`):

[source,python]
--------------------------------------------------
include::programs/ds_seq.py[]
--------------------------------------------------

Output:

--------------------------------------------------
include::programs/ds_seq.txt[]
--------------------------------------------------

.How It Works

First, we see how to use indexes to get individual items of a sequence. This is also referred to as
the _subscription operation_. Whenever you specify a number to a sequence within square brackets as
shown above, Python will fetch you the item corresponding to that position in the
sequence. Remember that Python starts counting numbers from 0. Hence, `shoplist[0]` fetches the
first item and `shoplist[3]` fetches the fourth item in the `shoplist`sequence.

The index can also be a negative number, in which case, the position is calculated from the end of
the sequence. Therefore, `shoplist[-1]` refers to the last item in the sequence and `shoplist[-2]`
fetches the second last item in the sequence.

The slicing operation is used by specifying the name of the sequence followed by an optional pair
of numbers separated by a colon within square brackets. Note that this is very similar to the
indexing operation you have been using till now. Remember the numbers are optional but the colon
isn't.

The first number (before the colon) in the slicing operation refers to the position from where the
slice starts and the second number (after the colon) indicates where the slice will stop at. If the
first number is not specified, Python will start at the beginning of the sequence. If the second
number is left out, Python will stop at the end of the sequence. Note that the slice returned
_starts_ at the start position and will end just before the _end_ position i.e. the start position
is included but the end position is excluded from the sequence slice.

Thus, `shoplist[1:3]` returns a slice of the sequence starting at position 1, includes position 2
but stops at position 3 and therefore a *slice* of two items is returned.  Similarly, `shoplist[:]`
returns a copy of the whole sequence.

You can also do slicing with negative positions. Negative numbers are used for positions from the
end of the sequence. For example, `shoplist[:-1]` will return a slice of the sequence which
excludes the last item of the sequence but contains everything else.

You can also provide a third argument for the slice, which is the _step_ for the slicing (by
default, the step size is 1):

[source,python]
--------------------------------------------------
>>> shoplist = ['apple', 'mango', 'carrot', 'banana']
>>> shoplist[::1]
['apple', 'mango', 'carrot', 'banana']
>>> shoplist[::2]
['apple', 'carrot']
>>> shoplist[::3]
['apple', 'banana']
>>> shoplist[::-1]
['banana', 'carrot', 'mango', 'apple']
--------------------------------------------------

Notice that when the step is 2, we get the items with position 0, 2,... When the step size is 3, we
get the items with position 0, 3, etc.

Try various combinations of such slice specifications using the Python interpreter interactively
i.e. the prompt so that you can see the results immediately. The great thing about sequences is
that you can access tuples, lists and strings all in the same way!

[[set]]
=== Set

Sets are _unordered_ collections of simple objects. These are used when the existence of an object
in a collection is more important than the order or how many times it occurs.

Using sets, you can test for membership, whether it is a subset of another set, find the
intersection between two sets, and so on.

[source,python]
--------------------------------------------------
>>> bri = set(['brazil', 'russia', 'india'])
>>> 'india' in bri
True
>>> 'usa' in bri
False
>>> bric = bri.copy()
>>> bric.add('china')
>>> bric.issuperset(bri)
True
>>> bri.remove('russia')
>>> bri & bric # OR bri.intersection(bric)
{'brazil', 'india'}
--------------------------------------------------

.How It Works

The example is pretty much self-explanatory because it involves basic set theory mathematics taught
in school.

[[references]]
=== References

When you create an object and assign it to a variable, the variable only _refers_ to the object and
does not represent the object itself!  That is, the variable name points to that part of your
computer's memory where the object is stored. This is called *binding* the name to the object.

Generally, you don't need to be worried about this, but there is a subtle effect due to references
which you need to be aware of:

Example (save as `ds_reference.py`):

[source,python]
--------------------------------------------------
include::programs/ds_reference.py[]
--------------------------------------------------

Output:

--------------------------------------------------
include::programs/ds_reference.txt[]
--------------------------------------------------

.How It Works

Most of the explanation is available in the comments.

Remember that if you want to make a copy of a list or such kinds of sequences or complex objects
(not simple _objects_ such as integers), then you have to use the slicing operation to make a
copy. If you just assign the variable name to another name, both of them will ''refer'' to the same
object and this could be trouble if you are not careful.

.Note for Perl programmers
[NOTE]
Remember that an assignment statement for lists does **not** create a copy. You have to use slicing
operation to make a copy of the sequence.

[[more_strings]]
=== More About Strings

We have already discussed strings in detail earlier. What more can there be to know?  Well, did you
know that strings are also objects and have methods which do everything from checking part of a
string to stripping spaces!

The strings that you use in program are all objects of the class `str`.  Some useful methods of
this class are demonstrated in the next example. For a complete list of such methods, see
`help(str)`.

Example (save as `ds_str_methods.py`):

[source,python]
--------------------------------------------------
include::programs/ds_str_methods.py[]
--------------------------------------------------

Output:

--------------------------------------------------
include::programs/ds_str_methods.txt[]
--------------------------------------------------

.How It Works

Here, we see a lot of the string methods in action. The `startswith` method is used to find out
whether the string starts with the given string. The `in` operator is used to check if a given
string is a part of the string.

The `find` method is used to locate the position of the given substring within the string; `find`
returns -1 if it is unsuccessful in finding the substring. The `str` class also has a neat method
to `join` the items of a sequence with the string acting as a delimiter between each item of the
sequence and returns a bigger string generated from this.

=== Summary

We have explored the various built-in data structures of Python in detail. These data structures
will be essential for writing programs of reasonable size.

Now that we have a lot of the basics of Python in place, we will next see how to design and write a
real-world Python program.
